/*
 *	component:   "openEHR Library Project"
 *	description: "Method dispatcher C interface"
 *	keywords:    "method dispatch cecil"
 *
 *	author:      "Thomas Beale"
 *	support:     "Ocean Informatics <support@OceanInformatics.biz>"
 *	copyright:   "Copyright (c) 2004 Ocean Informatics Pty Ltd"
 *	license:     "See notice at bottom of class"
 *
 *	file:        "$URL$"
 *	revision:    "$LastChangedRevision$"
 *	last_change: "$LastChangedDate$"
 */

#include "eif_eiffel.h"
#include "eif_except.h"


/*
 **************************************************************
 *                      Exception switch
 **************************************************************
 */

c_ignore_invisible() 
{
	eif_disable_visible_exception;
}


/*
 **************************************************************
 *                      FEATURE DISPATCH RESULTS
 **************************************************************
 */


EIF_REFERENCE		result_obj;
EIF_BOOLEAN		result_bool;
EIF_CHARACTER	result_char;
EIF_INTEGER		result_int;
EIF_REAL		result_float;
EIF_DOUBLE		result_double;
EIF_POINTER		result_pointer;
EIF_BIT			result_bit;


EIF_REFERENCE		c_result_obj()	{ return result_obj; }
EIF_BOOLEAN		c_result_bool() { return result_bool; }
EIF_CHARACTER	c_result_char() { return result_char; }
EIF_INTEGER		c_result_int() { return result_int; }
EIF_REAL		c_result_real() { return result_float; }
EIF_DOUBLE		c_result_double() { return result_double; }
EIF_POINTER		c_result_pointer() { return result_pointer; }
EIF_BIT			c_result_bit() { return result_bit; }


/*
 **************************************************************
 *                   VARIABLE ARGUMENT MARSHALLING
 **************************************************************
 */
#define MAX_ARGS 10

static int marshalled_arg_count;
static void* marshalled_args[MAX_ARGS];

void c_marshal_args_reset()
{
	int	i;

	marshalled_arg_count = 0;
	for(i = 0; i < MAX_ARGS; i++)
		marshalled_args[i] = NULL;
}

void c_marshal_int_arg(EIF_INTEGER arg)
{
	marshalled_args[marshalled_arg_count++] = (void *)arg;
}

void c_marshal_ptr_arg(EIF_POINTER arg)
{
	marshalled_args[marshalled_arg_count++] = arg;
}


/*
 **************************************************************
 *                   CLASS & FEATURE VALIDITY
 **************************************************************
 */

/*
 * Assumes type_name includes generic parameters if any. The full generic
 * type name can be generated using ANY.generating_type
 */
EIF_BOOLEAN
c_is_class_visible(char *type_name)
{
	return (eif_type_id(type_name) != EIF_NO_TYPE); 
}

EIF_INTEGER
c_eif_type_id(char *type_name)
{
	return (eif_type_id(type_name)); 
}

EIF_BOOLEAN
c_is_valid_feature(char *type_name, char *feat_name)
{
	void 		*ef;
	EIF_TYPE_ID	eti;

	ef = NULL;

	eti = eif_type_id(type_name); 
	if (eti != EIF_NO_TYPE) 
		ef = eif_procedure(feat_name, eti); 

	return (ef != NULL);
}


/*
 **************************************************************
 *                      OBJECT CREATION
 **************************************************************
 */


EIF_REFERENCE
c_create_object_by_id(EIF_TYPE_ID eti, char *make_proc_name)
{
	EIF_OBJECT		new_obj;
	EIF_PROCEDURE	ep;
	
	if (eti != EIF_NO_TYPE) {
		new_obj = eif_create(eti);
		if (make_proc_name != NULL) {
			ep = eif_procedure(make_proc_name, eti);
			(ep)(eif_access(new_obj), marshalled_args[0], marshalled_args[1], marshalled_args[2], marshalled_args[3], marshalled_args[4]);
		}
	}
	else
		eif_panic("No type id");

	c_marshal_args_reset();

	return eif_wean(new_obj);
}

/*
 * create an object by name; create generic objects by passing full type
 * name as generated by ANY.generating_type. Make args must be marshalled
 * in advance
 */
EIF_REFERENCE
c_create_obj(char *type_name, char *make_proc_name)
{
	return c_create_object_by_id(eif_type_id(type_name), make_proc_name);
}

EIF_REFERENCE
c_create_make_object_by_id(EIF_TYPE_ID eti, char *make_proc_name, EIF_REFERENCE make_arg)
{
	EIF_OBJECT		new_obj;
	EIF_PROCEDURE	ep;
	
	if (eti != EIF_NO_TYPE) {
		new_obj = eif_create(eti);
		if (make_proc_name != NULL) {
			ep = eif_procedure(make_proc_name, eti);
			(ep)(eif_access(new_obj), make_arg);
		}
	}
	else
		eif_panic("No type id");

	c_marshal_args_reset();

	return eif_wean(new_obj);
}


/*
 * create an object by name and call its make routine with a single argument
 * which must be a reference object
 */
EIF_REFERENCE
c_create_make_object(char *type_name, char *make_proc_name, EIF_REFERENCE make_arg)
{
	return c_create_make_object_by_id(eif_type_id(type_name), make_proc_name, make_arg);
}


/*
 **************************************************************
 *                      FEATURE DISPATCH
 **************************************************************
 */

/*
 * dispatch PROCEDURE call.
 */
void
c_dispatch_procedure(EIF_REFERENCE obj, char *feat_name, EIF_REFERENCE arg)
{
	void		*ef;
	EIF_TYPE_ID	eti;

	eti = Dtype(obj); 
	if (eti != EIF_NO_TYPE) {
		ef = eif_procedure(feat_name, eti); 
		if (ef != NULL) ((EIF_PROCEDURE) ef)(obj, arg);
	}
}


/*
 * dispatch REFERENCE FIELD call.
 */
void
c_dispatch_reference_field(EIF_REFERENCE obj, char *feat_name)
{
	EIF_TYPE_ID	eti;

	eti = Dtype(obj); 
	if (eti != EIF_NO_TYPE)
		result_obj = eif_field(obj, feat_name, EIF_REFERENCE); 
	else
		eif_panic("No type id");
}


/*
 * dispatch a field access to integer field
 */
void
c_dispatch_integer_field(EIF_POINTER obj, char *feat_name)
{
	EIF_TYPE_ID	eti;
	
	eti = Dtype(obj); 
	if (eti != EIF_NO_TYPE)
		result_int = eif_field((EIF_REFERENCE)obj, feat_name, EIF_INTEGER);
	else
		eif_panic("No type id");
}

/*
 * dispatch a field access to boolean field
 */
void
c_dispatch_boolean_field(EIF_POINTER obj, char *feat_name)
{
	EIF_TYPE_ID	eti;
	
	eti = Dtype(obj); 
	if (eti != EIF_NO_TYPE)
		result_bool = eif_field((EIF_REFERENCE)obj, feat_name, EIF_BOOLEAN);
	else
		eif_panic("No type id");
}

/*
 * dispatch a field access to real field
 */
void
c_dispatch_real_field(EIF_POINTER obj, char *feat_name)
{
	EIF_TYPE_ID	eti;
	
	eti = Dtype(obj); 
	if (eti != EIF_NO_TYPE)
		result_float = eif_field((EIF_REFERENCE)obj, feat_name, EIF_REAL);
	else
		eif_panic("No type id");
}

/*
 * dispatch a field access to double field
 */
void
c_dispatch_double_field(EIF_POINTER obj, char *feat_name)
{
	EIF_TYPE_ID	eti;
	
	eti = Dtype(obj); 
	if (eti != EIF_NO_TYPE)
		result_double = eif_field((EIF_REFERENCE)obj, feat_name, EIF_DOUBLE);
	else
		eif_panic("No type id");
}

/*
 * dispatch a field access to character field
 */
void
c_dispatch_character_field(EIF_POINTER obj, char *feat_name)
{
	EIF_TYPE_ID	eti;
	
	eti = Dtype(obj); 
	if (eti != EIF_NO_TYPE)
		result_char = eif_field((EIF_REFERENCE)obj, feat_name, EIF_CHARACTER);
	else
		eif_panic("No type id");
}



/*
 * dispatch FUNCTION call. Caller must inspect relevant result_xxx 
 * variable afterwards
 */
void
c_dispatch_function(EIF_REFERENCE obj, char *feat_name, EIF_REFERENCE arg, EIF_INTEGER feat_type)
{
	void		*ef;
	EIF_TYPE_ID	eti;

	eti = Dtype(obj); 
	switch (feat_type) {

	case EIF_NO_TYPE:
		eif_panic("No type id");
		break;

	case EIF_REFERENCE_TYPE:
		ef = eif_reference_function(feat_name, eti); 
		if (ef != NULL) result_obj = ((EIF_REFERENCE_FUNCTION) ef)(obj, arg);
		break;

	case EIF_BOOLEAN_TYPE:
		ef = eif_boolean_function(feat_name, eti); 
		if (ef != NULL) result_bool = ((EIF_BOOLEAN_FUNCTION) ef)(obj, arg);
		break;

	case EIF_CHARACTER_TYPE:
		ef = eif_character_function(feat_name, eti); 
		if (ef != NULL) result_char = ((EIF_CHARACTER_FUNCTION) ef)(obj, arg);
		break;

	case EIF_INTEGER_TYPE:
		ef = eif_integer_function(feat_name, eti); 
		if (ef != NULL) result_int = ((EIF_INTEGER_FUNCTION) ef)(obj, arg);
		break;

	case EIF_REAL_TYPE:
		ef = eif_real_function(feat_name, eti); 
		if (ef != NULL) result_float = ((EIF_REAL_FUNCTION) ef)(obj, arg);
		break;

	case EIF_DOUBLE_TYPE:
		ef = eif_double_function(feat_name, eti); 
		if (ef != NULL) result_double = ((EIF_DOUBLE_FUNCTION) ef)(obj, arg);
		break;

	case EIF_POINTER_TYPE:
		ef = eif_pointer_function(feat_name, eti); 
		if (ef != NULL) result_pointer = ((EIF_POINTER_FUNCTION) ef)(obj, arg);
		break;

	case EIF_BIT_TYPE:
		ef = eif_bit_function(feat_name, eti); 
		if (ef != NULL) result_bit = ((EIF_BIT_FUNCTION) ef)(obj, arg);
		break;

	default:
		break;

	}
}

	
/*
 *  ***** BEGIN LICENSE BLOCK *****
 *  Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * 
 *  The contents of this file are subject to the Mozilla Public License Version
 *  1.1 (the 'License'); you may not use this file except in compliance with
 *  the License. You may obtain a copy of the License at
 *  http://www.mozilla.org/MPL/
 * 
 *  Software distributed under the License is distributed on an 'AS IS' basis,
 *  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 *  for the specific language governing rights and limitations under the
 *  License.
 * 
 *  The Original Code is method_dispatcher.c
 * 
 *  The Initial Developer of the Original Code is Thomas Beale.
 *  Portions created by the Initial Developer are Copyright (C) 2003-2004
 *  the Initial Developer. All Rights Reserved.
 * 
 *  Contributor(s):
 * 
 *  Alternatively, the contents of this file may be used under the terms of
 *  either the GNU General Public License Version 2 or later (the 'GPL'), or
 *  the GNU Lesser General Public License Version 2.1 or later (the 'LGPL'),
 *  in which case the provisions of the GPL or the LGPL are applicable instead
 *  of those above. If you wish to allow use of your version of this file only
 *  under the terms of either the GPL or the LGPL, and not to allow others to
 *  use your version of this file under the terms of the MPL, indicate your
 *  decision by deleting the provisions above and replace them with the notice
 *  and other provisions required by the GPL or the LGPL. If you do not delete
 *  the provisions above, a recipient may use your version of this file under
 *  the terms of any one of the MPL, the GPL or the LGPL.
 * 
 *  ***** END LICENSE BLOCK *****
 */
